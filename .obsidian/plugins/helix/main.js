/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HelixPlugin
});
module.exports = __toCommonJS(main_exports);

// node_modules/codemirror-helix/dist/lib.js
var import_commands = require("@codemirror/commands");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_search = require("@codemirror/search");
var import_state2 = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var import_state3 = require("@codemirror/state");
var import_state4 = require("@codemirror/state");
var import_language = require("@codemirror/language");
var import_commands2 = require("@codemirror/commands");
var import_search2 = require("@codemirror/search");
var modeEffect = import_state2.StateEffect.define();
var modeField = import_state2.StateField.define({
  create() {
    return {
      type: 0,
      minor: 2
      /* Normal */
    };
  },
  update(mode, tr) {
    for (const effect of tr.effects) {
      if (effect.is(modeEffect)) {
        mode = effect.value;
      }
    }
    return mode;
  }
});
function resetMode(mode, override) {
  return modeEffect.of({ type: mode.type, minor: mode.minor, ...override });
}
function overwriteMode(mode, override) {
  return modeEffect.of({ ...mode, ...override });
}
function sameMode(mode, otherMode) {
  return mode.type === otherMode.type && mode.minor === otherMode.minor;
}
function sameModeState(mode, otherMode) {
  return sameMode(mode, otherMode) && mode.count === otherMode.count && mode.register === otherMode.register && mode.expecting === otherMode.expecting;
}
function modeStatus(mode) {
  let result = "";
  if (mode.type !== 1) {
    if (mode.count) {
      result += mode.count;
    }
    result += minorModeStr(mode.minor);
  }
  if (mode.expecting) {
    result += mode.expecting.minor;
  }
  return result;
}
function minorModeStr(minor) {
  switch (minor) {
    case 2:
      return "";
    case 3:
      return "g";
    case 5:
      return "m";
    case 6:
      return "<space>";
    case 7:
      return "[";
    case 8:
      return "]";
    default: {
      if (false) {
        throw new Error("Unexpected mode");
      }
    }
  }
}
var yankEffect = import_state2.StateEffect.define();
function readRegister(state, register) {
  switch (register) {
    case "#": {
      return state.selection.ranges.map((_, i) => String(i + 1));
    }
    case "_": {
      return [];
    }
    case ".": {
      return state.selection.ranges.map(
        (range) => state.sliceDoc(range.from, range.to)
      );
    }
    case "%": {
      const path = state.facet(pathRegister);
      return path != null ? [path] : [];
    }
    default: {
      return state.field(registersField)[register != null ? register : `"`];
    }
  }
}
async function readClipboard(state) {
  const yanked = readRegister(state, "+");
  const copied = await navigator.clipboard.readText();
  if ((yanked == null ? void 0 : yanked.map((yank2) => yank2.toString()).join("\n")) === copied) {
    return yanked;
  }
  return [copied];
}
var registersField = import_state2.StateField.define({
  create() {
    return {};
  },
  update(registers, tr) {
    for (const effect of tr.effects) {
      if (effect.is(yankEffect)) {
        if (!Array.isArray(effect.value)) {
          registers = effect.value.reset.values;
          if (false) {
            const regs = new Set(Object.keys(registers));
            if (["_", "%", ".", "#"].some((reg2) => regs.has(reg2))) {
              console.error(`unexpected read-only register`);
            }
          }
          continue;
        }
        const [reg] = effect.value;
        let [, value] = effect.value;
        switch (reg) {
          case "_":
          case "%":
          case ".":
          case "#": {
            return registers;
          }
          case ":": {
            value = value.length ? [value[0]] : [];
            break;
          }
          case "+": {
            navigator.clipboard.writeText(
              // FIXME: proper line ending?
              value.map((yank2) => yank2.toString()).join("\n")
            );
            break;
          }
        }
        if (value.length === 0) {
          const { [reg]: _reg, ...rest } = registers;
          registers = rest;
        } else {
          registers = { ...registers, [reg]: value };
        }
      }
    }
    return registers;
  }
});
var registersHistoryField = import_state2.StateField.define({
  create() {
    return {};
  },
  update(registers, tr) {
    for (const effect of tr.effects) {
      if (effect.is(yankEffect)) {
        if (!Array.isArray(effect.value)) {
          registers = effect.value.reset.history;
          continue;
        }
        const [reg] = effect.value;
        let [, value] = effect.value;
        switch (reg) {
          case ":": {
            value = value.length ? [value[0]] : [];
            break;
          }
          case "/": {
            break;
          }
          default: {
            continue;
          }
        }
        if (value.length === 0) {
          continue;
        }
        const { [reg]: current, ...rest } = registers;
        registers = {
          [reg]: [...current != null ? current : [], value[0]],
          ...rest
        };
      }
    }
    return registers;
  }
});
var historyEffect = import_state2.StateEffect.define();
var historyField = import_state2.StateField.define({
  create() {
    return { checkpoints: [], cursor: -1, pending: null, head: null };
  },
  update(value, tr) {
    var _a, _b;
    for (const effect of tr.effects) {
      if (effect.is(historyEffect)) {
        const effectValue = effect.value;
        switch (effectValue.type) {
          case "move": {
            const cursor = value.cursor + effectValue.offset;
            value = {
              checkpoints: value.checkpoints,
              pending: null,
              cursor,
              head: (_b = (_a = value.head) != null ? _a : effectValue.head) != null ? _b : null
            };
            break;
          }
          case "add": {
            if (false) {
              if (value.pending && effectValue.temp) {
                throw new Error("Unexpected temp");
              }
            }
            const checkpoints = value.cursor === -1 ? value.checkpoints : value.checkpoints.slice(value.cursor + 1);
            value = effectValue.temp ? {
              checkpoints: value.checkpoints,
              cursor: value.cursor,
              pending: effectValue.state,
              head: value.head
            } : {
              checkpoints: [effectValue.state, ...checkpoints],
              cursor: -1,
              pending: null,
              head: null
            };
            break;
          }
          case "commit": {
            if (false) {
              if (!value.pending) {
                throw new Error("unexpected commit");
              }
            }
            if (effectValue.state.doc.eq(value.pending.doc)) {
              value = {
                ...value,
                pending: null
              };
              break;
            }
            const checkpoints = value.cursor === -1 ? value.checkpoints : value.checkpoints.slice(value.cursor + 1);
            value = {
              checkpoints: [value.pending, ...checkpoints],
              cursor: -1,
              pending: null,
              head: null
            };
            break;
          }
        }
      }
    }
    return value;
  }
});
var syntaxHistoryEffect = import_state2.StateEffect.define();
var syntaxHistoryField = import_state2.StateField.define({
  create() {
    return { selections: [], cursor: 0, head: null, frozen: false };
  },
  update(value, tr) {
    var _a;
    for (const effect of tr.effects) {
      if (effect.is(syntaxHistoryEffect)) {
        switch (effect.value.type) {
          case "freeze": {
            value = { ...value, frozen: (_a = effect.value.frozen) != null ? _a : true };
            break;
          }
          case "add": {
            value = {
              selections: [...value.selections, effect.value.prev],
              cursor: value.cursor + 1,
              head: effect.value.next,
              frozen: false
            };
            break;
          }
          case "move": {
            value = {
              ...value,
              cursor: value.cursor + effect.value.offset
            };
            break;
          }
          case "reset": {
            if (!value.frozen) {
              value = {
                frozen: false,
                selections: [],
                cursor: 0,
                head: null
              };
            }
          }
        }
      }
    }
    return value;
  }
});
function expandSyntaxHistory(state, expand, done) {
  const history = state.field(syntaxHistoryField);
  if (history.cursor < history.selections.length) {
    done({
      selection: history.cursor === history.selections.length - 1 ? history.head : history.selections[history.cursor + 1],
      effects: syntaxHistoryEffect.of({ type: "move", offset: 1 })
    });
    return;
  }
  expand(
    {
      effects: syntaxHistoryEffect.of({ type: "freeze" })
    },
    (tr) => {
      var _a;
      done(
        ((_a = tr.selection) == null ? void 0 : _a.eq(state.selection)) ? {
          effects: syntaxHistoryEffect.of({
            type: "freeze",
            frozen: false
          })
        } : {
          selection: tr.selection,
          changes: tr.changes,
          scrollIntoView: tr.scrollIntoView,
          effects: [
            ...tr.effects,
            syntaxHistoryEffect.of({
              type: "add",
              prev: state.selection,
              next: tr.newSelection
            })
          ]
        }
      );
    }
  );
}
function undoSyntaxHistory(state) {
  const history = state.field(syntaxHistoryField);
  if (history.cursor > 0) {
    return {
      selection: history.selections[history.cursor - 1],
      effects: syntaxHistoryEffect.of({ type: "move", offset: -1 })
    };
  }
}
var themeCompartment = new import_state2.Compartment();
var themeEffect = import_state2.StateEffect.define();
var themeField = import_state2.StateField.define({
  create() {
    return {};
  },
  update(value, tr) {
    for (const effect of tr.effects) {
      if (effect.is(themeEffect)) {
        value = { ...value, current: effect.value };
      }
    }
    return value;
  }
});
var MOUNT_EVENT = "cm-hx-input-mounted";
var panelStyles = import_view2.EditorView.theme({
  ".cm-hx-status-panel": {
    display: "flex",
    "justify-content": "space-between",
    "font-family": "monospace"
  },
  ".cm-hx-command-panel": {
    fontFamily: "monospace",
    minHeight: "18px",
    background: "inherit"
  },
  ".cm-hx-command-panel-flex": {
    display: "flex",
    justifyContent: "space-between",
    background: "inherit"
  },
  ".cm-hx-command-input": {
    "flex-grow": 100,
    fontFamily: "monospace",
    fontSize: "inherit",
    border: "none",
    outline: "none",
    padding: "0",
    margin: "0",
    background: "inherit",
    color: "inherit"
  },
  ".cm-hx-command-autocomplete": {
    display: "grid",
    "grid-template-columns": "repeat(auto-fill, minmax(10em, 1fr))",
    gap: "1px 0px"
  },
  ".cm-hx-command-popup-wrapper": {
    width: "100%",
    background: "inherit",
    position: "relative"
  },
  ".cm-hx-command-popup": {
    position: "absolute",
    background: "inherit",
    width: "inherit"
  },
  ".cm-hx-command-help": {
    border: "1px solid #777",
    "line-height": "1.5",
    background: "inherit",
    padding: "4px 8px",
    whiteSpace: "preserve"
  }
});
var panelTheme = {
  light: import_view2.EditorView.theme({
    ".cm-hx-selected-option": {
      background: "#ccc"
    }
  }),
  dark: import_view2.EditorView.theme({
    ".cm-hx-selected-option": {
      background: "#777"
    }
  })
};
var CommandPanel = class {
  constructor(view, commandFacet, startSearch2) {
    __publicField(this, "dom");
    __publicField(this, "minorCommand");
    __publicField(this, "inputContainer");
    __publicField(this, "label");
    __publicField(this, "message", false);
    __publicField(this, "commandPopup");
    __publicField(this, "autocomplete");
    __publicField(this, "help");
    __publicField(this, "popupRequest");
    this.view = view;
    this.commandFacet = commandFacet;
    this.startSearch = startSearch2;
    this.dom = $el("div");
    const popupWrapper = $el("div");
    popupWrapper.classList.add("cm-hx-command-popup-wrapper");
    const flex = $el("div");
    flex.classList.add("cm-hx-command-panel-flex");
    this.minorCommand = $el("span");
    this.inputContainer = $el("span");
    this.commandPopup = $el("div");
    popupWrapper.append(this.commandPopup);
    flex.append(this.inputContainer);
    flex.append(this.minorCommand);
    this.dom.append(flex);
    this.dom.append(popupWrapper);
    this.dom.classList.add("cm-hx-command-panel");
    $style(this.inputContainer, {
      visibility: "hidden",
      flexGrow: "1",
      display: "flex"
    });
    this.label = $el("span");
    this.inputContainer.append(this.label);
    this.commandPopup.classList.add("cm-hx-command-popup");
    this.help = $el("div");
    this.autocomplete = $el("div");
    this.help.hidden = true;
    this.help.classList.add("cm-hx-command-help");
    this.autocomplete.classList.add("cm-hx-command-autocomplete");
    this.commandPopup.append(this.help);
    this.commandPopup.append(this.autocomplete);
    $style(this.minorCommand, { minWidth: "8em", textAlign: "center " });
  }
  showSearchInput(mode = 0) {
    const input = this.searchInput(mode);
    this.showInput(
      input,
      mode === 1 ? "global-search:" : "search:"
    );
  }
  showCommandInput() {
    const input = this.commandInput();
    this.showInput(input, ":");
  }
  showMinor(command) {
    this.minorCommand.textContent = modeStatus(command);
  }
  showInput(input, label) {
    this.label.textContent = label;
    $style(this.label, { color: "" });
    this.inputContainer.append(input);
    $style(this.inputContainer, { visibility: "" });
    input.dispatchEvent(new Event(MOUNT_EVENT));
    input.focus();
  }
  createInput({
    onInput,
    onClose,
    placeholder,
    onKeyDown,
    getPopup,
    getHistory,
    accept
  }) {
    const input = $el("input");
    let currentPopup;
    let selected;
    let historyEntry = -1;
    if (onKeyDown) {
      input.addEventListener("keydown", onKeyDown);
    }
    input.addEventListener(MOUNT_EVENT, () => {
      currentPopup = getPopup(input.value);
      this.showPopup(currentPopup.options, currentPopup.help, void 0);
    });
    if (placeholder) {
      input.placeholder = placeholder;
    }
    input.classList.add("cm-hx-command-input");
    input.type = "text";
    let open = true;
    input.addEventListener("blur", () => {
      if (open) {
        this.hidePopup();
        selected = void 0;
        onClose(false, input.value);
      }
    });
    input.addEventListener("input", () => {
      selected = void 0;
      currentPopup = getPopup(input.value);
      this.showPopup(currentPopup.options, currentPopup.help, void 0);
      onInput(input.value);
    });
    input.addEventListener("keydown", (event) => {
      var _a, _b;
      if (event.isComposing) {
        return;
      }
      const isEnter = event.key === "Enter";
      if (isEnter || event.key === "Escape") {
        open = false;
        this.hidePopup();
        selected = void 0;
        onClose(isEnter, input.value);
      } else if (event.key === "Tab" && (currentPopup == null ? void 0 : currentPopup.options.length)) {
        event.preventDefault();
        const forward = !event.shiftKey;
        const prev = selected;
        if (selected != null) {
          selected = (selected + (forward ? 1 : -1) + currentPopup.options.length) % currentPopup.options.length;
        } else {
          selected = forward ? 0 : currentPopup.options.length - 1;
        }
        if (prev !== selected) {
          const selectedOption = currentPopup.options[selected];
          const nextPopup = getPopup(selectedOption);
          currentPopup = { ...nextPopup, options: currentPopup.options };
          this.showPopup(currentPopup.options, currentPopup.help, selected);
          input.value = (_a = accept == null ? void 0 : accept(selectedOption)) != null ? _a : selectedOption;
        }
        onInput(input.value);
      } else if (event.key === "ArrowUp" || event.key === "ArrowDown") {
        event.preventDefault();
        const history = (_b = getHistory()) != null ? _b : [];
        const next = historyEntry + (event.key === "ArrowUp" ? 1 : -1);
        if (next >= 0 && next < history.length) {
          historyEntry = next;
          const value = history[history.length - 1 - historyEntry].toString();
          currentPopup = getPopup(value);
          this.showPopup(currentPopup.options, currentPopup.help, selected);
          input.value = value;
          input.selectionStart = value.length;
        }
      }
    });
    return input;
  }
  commandInput() {
    var _a, _b;
    const { view } = this;
    const initialSelection = view.state.selection;
    const initialScroll = view.scrollSnapshot();
    const isNumber = (cmd) => /^\d+$/.test(cmd);
    let readingRegister = false;
    const input = this.createInput({
      placeholder: (_b = (_a = readRegister(view.state, ":")) == null ? void 0 : _a.at(0)) == null ? void 0 : _b.toString(),
      getHistory: () => this.view.state.field(registersHistoryField)[":"],
      onKeyDown(e) {
        var _a2, _b2, _c;
        if (e.isComposing) {
          return;
        }
        if (e.key === "r" && e.ctrlKey) {
          readingRegister = true;
        } else if (readingRegister && e.key === "Escape") {
          readingRegister = false;
        } else if (readingRegister && e.key.length === 1) {
          readingRegister = false;
          input.value += (_c = (_b2 = (_a2 = readRegister(view.state, e.key)) == null ? void 0 : _a2.at(0)) == null ? void 0 : _b2.toString()) != null ? _c : "";
        } else if (!readingRegister) {
          return;
        }
        e.stopPropagation();
        e.preventDefault();
      },
      onClose: (commit, value) => {
        var _a2, _b2, _c;
        if (commit && value) {
          view.dispatch({
            effects: yankEffect.of([":", [value]])
          });
        } else if (commit) {
          value = (_c = (_b2 = (_a2 = readRegister(view.state, ":")) == null ? void 0 : _a2.at(0)) == null ? void 0 : _b2.toString()) != null ? _c : "";
        }
        const [cmd, ...args] = value.trimEnd().split(/ +/);
        if (commit && cmd) {
          const commands2 = view.state.facet(this.commandFacet);
          const command = commands2.find(
            (command2) => {
              var _a3;
              return command2.name === cmd || ((_a3 = command2.aliases) == null ? void 0 : _a3.some((alias) => alias === cmd));
            }
          );
          const result = command ? command.handler(view, args) : {
            message: `no such command: '${cmd}'`,
            error: true
          };
          if (result) {
            this.showMessageAndCloseInput(result);
            return;
          }
        } else if (!commit && isNumber(cmd)) {
          view.dispatch({
            selection: initialSelection
          });
          setTimeout(() => {
            view.dispatch({
              effects: initialScroll
            });
          });
        }
        this.closeInput();
      },
      onInput: (value) => {
        const args = value.split(/ +/);
        const cmd = args.at(0);
        if (!cmd) {
          return;
        }
        if (isNumber(cmd)) {
          const lineNo = Number(cmd);
          if (lineNo >= 1 && lineNo <= view.state.doc.lines) {
            const line = view.state.doc.line(lineNo);
            view.dispatch({
              selection: import_state3.EditorSelection.cursor(line.from),
              effects: import_view2.EditorView.scrollIntoView(line.from, { y: "center" })
            });
          }
          return;
        }
      },
      getPopup: (value) => {
        const args = value.split(/ +/);
        const cmd = args.at(0);
        if (cmd == null) {
          return { options: [] };
        }
        const commands2 = view.state.facet(this.commandFacet);
        const possibleCommands = commands2.filter(
          (command2) => {
            var _a2;
            return command2.name.startsWith(cmd) || ((_a2 = command2.aliases) == null ? void 0 : _a2.some((alias) => alias.startsWith(cmd)));
          }
        );
        const command = possibleCommands.find(
          (command2) => {
            var _a2;
            return command2.name === cmd || ((_a2 = command2.aliases) == null ? void 0 : _a2.includes(cmd));
          }
        );
        function commandToHelp(command2) {
          let help2 = "";
          if (command2) {
            help2 = `${command2.help}`;
            if (command2.aliases && command2.aliases.length > 0) {
              help2 += `
Aliases: ${command2.aliases.join(", ")}`;
            }
          }
          return help2;
        }
        const help = command != null ? commandToHelp(command) : void 0;
        if (args[1] != null && command && command.autocomplete) {
          const options = command.autocomplete(args.slice(1));
          return { options, help };
        } else {
          return {
            options: possibleCommands.map((command2) => command2.name),
            help
          };
        }
      },
      accept(value) {
        const last = input.value.split(/ +/).at(-1);
        if (last == null) {
          return void 0;
        }
        return input.value.slice(0, input.value.length - last.length) + `${value}`;
      }
    });
    return input;
  }
  showError(message) {
    this.showMessage({ message, error: true });
  }
  showMessage(messageOrResult) {
    if (messageOrResult == null) {
      return;
    }
    const [message, error] = typeof messageOrResult === "string" ? [messageOrResult, false] : [messageOrResult.message, messageOrResult.error];
    $style(this.inputContainer, { visibility: "" });
    this.message = true;
    $style(this.label, { color: error ? "red" : "" });
    this.label.textContent = message;
  }
  showMessageAndCloseInput(result) {
    this.showMessage(result);
    this.closeInput(!result);
  }
  hasMessage() {
    return this.message;
  }
  clearMessage() {
    if (this.message) {
      this.message = false;
      this.label.textContent = "";
      $style(this.inputContainer, { visibility: "hidden" });
    }
  }
  showPopup(options, help, selected) {
    var _a;
    if (options.length === 0) {
      this.hidePopup();
      return;
    }
    this.commandPopup.hidden = false;
    this.help.hidden = !help;
    this.help.textContent = help != null ? help : "";
    while (options.length > this.autocomplete.childNodes.length) {
      const entry = $el("span");
      $style(entry, { marginRight: "1em" });
      this.autocomplete.append(entry);
    }
    for (const [i, child] of this.autocomplete.childNodes.entries()) {
      const option = options[i];
      if (option) {
        child.textContent = option;
        child.style.order = "";
      } else {
        break;
      }
    }
    while (this.autocomplete.childNodes.length > options.length) {
      (_a = this.autocomplete.lastChild) == null ? void 0 : _a.remove();
    }
    const current = this.autocomplete.querySelector(".cm-hx-selected-option");
    current == null ? void 0 : current.classList.remove("cm-hx-selected-option");
    if (selected != null) {
      this.autocomplete.children[selected].classList.add(
        "cm-hx-selected-option"
      );
    }
    if (this.popupRequest == null) {
      this.popupRequest = requestAnimationFrame(() => this.positionPopup());
    }
  }
  hidePopup() {
    this.commandPopup.hidden = true;
  }
  positionPopup() {
    this.popupRequest = void 0;
    if (this.commandPopup.hidden) {
      return;
    }
    const inputBox = this.inputContainer.getBoundingClientRect();
    const wrapperBox = this.commandPopup.parentElement.getBoundingClientRect();
    $style(this.commandPopup, {
      bottom: `${wrapperBox.top - inputBox.top}px`,
      left: "0px"
    });
    let i = -1;
    const base = this.autocomplete.children.item(0).getBoundingClientRect().x;
    for (let index = 1; index < this.autocomplete.children.length; index++) {
      const child = this.autocomplete.children.item(index);
      if (child.getBoundingClientRect().x === base) {
        i = index;
        break;
      }
    }
    const width = i < 0 ? 1 : i;
    let order = 0;
    for (let i2 = 0; i2 < width; i2++) {
      for (let j = i2; j < this.autocomplete.children.length; j += width) {
        this.autocomplete.children.item(order).style.order = String(j);
        order++;
      }
    }
  }
  searchInput(mode) {
    const search = this.startSearch(mode);
    return this.createInput({
      placeholder: search.init,
      getHistory: () => this.view.state.field(registersHistoryField)["/"],
      onClose: (commit) => {
        this.showMessageAndCloseInput(search.onClose(commit));
      },
      onInput: (value) => {
        search.onInput(value);
      },
      getPopup: (value) => {
        var _a;
        const history = (_a = this.view.state.field(registersHistoryField)["/"]) != null ? _a : [];
        const options = history.flatMap((entry) => {
          const text = entry.toString();
          return text.startsWith(value) ? [text] : [];
        });
        options.sort();
        return { options };
      }
    });
  }
  closeInput(hide = true) {
    this.inputContainer.removeChild(this.inputContainer.lastChild);
    if (hide) {
      $style(this.inputContainer, { visibility: "hidden" });
    }
    requestAnimationFrame(() => {
      this.view.focus();
    });
  }
};
function statusPanel(view) {
  const dom = $el("div");
  dom.classList.add("cm-hx-status-panel");
  const mode = $el("span");
  mode.textContent = "NOR";
  dom.append(mode);
  const register = $el("span");
  dom.append(register);
  const pos = $el("span");
  dom.append(pos);
  function setLineCol() {
    const { line, column } = lineCol(view);
    pos.textContent = `${line}:${column}`;
  }
  setLineCol();
  return {
    dom,
    setMode(modeStr, activeRegister) {
      mode.textContent = modeStr;
      register.textContent = activeRegister ? `reg=${activeRegister}` : "";
    },
    setLineCol
  };
}
function lineCol(view) {
  const head = view.state.selection.main.head;
  const lineDesc = view.state.doc.lineAt(head);
  const line = lineDesc.number;
  const column = head - lineDesc.from + 1;
  return { line, column };
}
function $el(tag) {
  return document.createElement(tag);
}
function $style(el, styles) {
  Object.assign(el.style, styles);
}
var MODE_EFF = {
  NORMAL: modeEffect.of({
    type: 0,
    minor: 2
    /* Normal */
  }),
  SELECT: modeEffect.of({
    type: 4,
    minor: 2
    /* Normal */
  }),
  INSERT: modeEffect.of({
    type: 1
    /* Insert */
  })
};
function moveByChar(view, mode, forward) {
  const select = mode.type === 4;
  const next = select ? selectByChar(view, mode, forward) : cursorByChar(view, mode, forward);
  if (view.state.selection.eq(next)) {
    return false;
  }
  view.dispatch({
    selection: next,
    effects: resetCount(mode),
    scrollIntoView: true
  });
  return true;
}
function withHelixSelection(view, command) {
  view.dispatch({
    selection: mapSel(
      view.state.selection,
      (range) => cmSelToInternal(range, view.state.doc)
    )
  });
  const result = command(view);
  view.dispatch({
    selection: mapSel(
      view.state.selection,
      (range) => internalSelToCM(range, view.state.doc)
    )
  });
  return result;
}
function cmSelToInternal(range, doc) {
  var _a;
  if (range.empty) {
    return range;
  }
  const end = nextClusterBreak(doc, range.to, false);
  const [anchor, head] = rangeIsForward(range) ? [range.from, end] : [end, range.from];
  return import_state4.EditorSelection.range(
    anchor,
    head,
    range.goalColumn,
    (_a = range.bidiLevel) != null ? _a : void 0
  );
}
function removeText(view, { yank: yank2, edit } = {}) {
  const effects = [];
  yank2 != null ? yank2 : yank2 = true;
  if (yank2) {
    effects.push(
      yankEffect.of([
        `"`,
        view.state.selection.ranges.map(
          (range) => view.state.doc.slice(range.from, range.to)
        )
      ])
    );
  }
  if (edit) {
    effects.push(MODE_EFF.INSERT);
  }
  view.dispatch({
    effects,
    changes: view.state.selection.ranges.map((range) => ({
      from: range.from,
      to: range.to,
      insert: ""
    }))
  });
  if (!edit && view.state.selection.ranges.some((range) => range.empty)) {
    view.dispatch({
      selection: mapSel(
        view.state.selection,
        (range) => internalSelToCM(range, view.state.doc)
      )
    });
  }
}
function internalSelToCM(range, doc) {
  var _a;
  const end = nextClusterBreak(doc, range.to, true);
  const [anchor, head] = rangeIsForward(range) ? [range.from, end] : [end, range.from];
  return import_state4.EditorSelection.range(
    anchor,
    head,
    range.goalColumn,
    (_a = range.bidiLevel) != null ? _a : void 0
  );
}
function cursorToLineStart(view, mode) {
  const isNormal = mode.type === 0;
  withHelixSelection(
    view,
    (view2) => isNormal ? (0, import_commands2.cursorLineStart)(view2) : (0, import_commands2.selectLineStart)(view2)
  );
  view.dispatch({
    effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT
  });
}
function cursorToLineEndRange(range, view, mode) {
  const selection = cmSelToInternal(range, view.state.doc);
  const line = view.state.doc.lineAt(selection.head);
  if (line.length === 0) {
    return selection;
  }
  const goal = mode === 1 ? line.to : nextClusterBreak(view.state.doc, line.to, false);
  return mode === 4 ? import_state4.EditorSelection.range(selection.anchor, goal, selection.goalColumn) : import_state4.EditorSelection.cursor(goal, void 0, void 0, selection.goalColumn);
}
function cursorToLineEnd(view, mode, insert) {
  const select = mode.type === 4;
  view.dispatch({
    selection: mapSel(view.state.selection, (range) => {
      const next = cursorToLineEndRange(
        range,
        view,
        insert ? 1 : mode.type
      );
      return insert ? next : internalSelToCM(next, view.state.doc);
    }),
    effects: insert ? MODE_EFF.INSERT : select ? MODE_EFF.SELECT : MODE_EFF.NORMAL
  });
  return true;
}
function cursorByChar(view, mode, forward) {
  const doc = view.state.doc;
  const count = cmdCount(mode);
  return mapSel(view.state.selection, (range) => {
    let counter = count;
    const by = count > 1 ? () => () => {
      counter--;
      return counter > 0;
    } : void 0;
    const cursor = cmSelToInternal(range, doc).head;
    const moved = view.moveByChar(import_state4.EditorSelection.cursor(cursor), forward, by);
    return internalSelToCM(import_state4.EditorSelection.cursor(moved.head), doc);
  });
}
function selectByChar(view, mode, forward) {
  const doc = view.state.doc;
  const count = cmdCount(mode);
  return mapSel(view.state.selection, (range) => {
    const initial = cmSelToInternal(range, doc);
    let counter = count;
    const by = count > 1 ? () => () => {
      counter--;
      return counter > 0;
    } : void 0;
    const next = view.moveByChar(
      import_state4.EditorSelection.cursor(initial.head),
      forward,
      by
    );
    return internalSelToCM(
      import_state4.EditorSelection.range(initial.anchor, next.head),
      doc
    );
  });
}
function selectByLine(view, mode, forward) {
  const doc = view.state.doc;
  const count = cmdCount(mode);
  return mapSel(view.state.selection, (range) => {
    const initial = cmSelToInternal(range, doc);
    let selection = initial;
    for (let _i = 0; _i < count; _i++) {
      selection = view.moveVertically(
        import_state4.EditorSelection.cursor(
          selection.head,
          void 0,
          void 0,
          selection.goalColumn
        ),
        forward
      );
    }
    return internalSelToCM(
      import_state4.EditorSelection.range(
        initial.anchor,
        selection.head,
        selection.goalColumn
      ),
      doc
    );
  });
}
function cursorByLine(view, mode, forward) {
  const doc = view.state.doc;
  const count = cmdCount(mode);
  return mapSel(view.state.selection, (range) => {
    const selection = cmSelToInternal(range, doc);
    let cursor = selection.head;
    let goalColumn = selection.goalColumn;
    for (let _i = 0; _i < count; _i++) {
      const line = doc.lineAt(cursor).number;
      if (forward && line === doc.lines || !forward && line === 1) {
        break;
      }
      const next = view.moveVertically(
        import_state4.EditorSelection.cursor(cursor, void 0, void 0, goalColumn),
        forward
      );
      cursor = next.to;
      goalColumn = next.goalColumn;
    }
    return internalSelToCM(
      import_state4.EditorSelection.cursor(cursor, void 0, void 0, goalColumn),
      doc
    );
  });
}
function moveByHalfPage(view, mode, forward) {
  const select = mode.type === 4;
  const next = select ? selectByHalfPage(view, forward) : cursorByHalfPage(view, forward);
  if (next.eq(view.state.selection)) {
    return false;
  }
  view.dispatch({
    selection: next,
    scrollIntoView: true
  });
}
function cursorByHalfPage(view, forward) {
  return mapSel(view.state.selection, (range) => {
    const doc = view.state.doc;
    const selection = cmSelToInternal(range, doc);
    const lineBlock = view.lineBlockAt(doc.lineAt(selection.head).from);
    const end = view.lineBlockAt(forward ? doc.length : 0);
    const height = Math.min(
      view.scrollDOM.clientHeight / 2,
      Math.abs(lineBlock.top - end.top)
    );
    if (height < 1) {
      return range;
    }
    const next = view.moveVertically(
      import_state4.EditorSelection.cursor(
        selection.head,
        void 0,
        void 0,
        selection.goalColumn
      ),
      forward,
      height
    );
    return internalSelToCM(next, doc);
  });
}
function selectByHalfPage(view, forward) {
  return mapSel(view.state.selection, (range) => {
    const doc = view.state.doc;
    const selection = cmSelToInternal(range, doc);
    const lineBlock = view.lineBlockAt(doc.lineAt(selection.head).from);
    const end = view.lineBlockAt(forward ? doc.length : 0);
    const height = Math.min(
      view.scrollDOM.clientHeight / 2,
      Math.abs(lineBlock.top - end.top)
    );
    if (height < 1) {
      return range;
    }
    const next = view.moveVertically(
      import_state4.EditorSelection.cursor(
        selection.head,
        void 0,
        void 0,
        selection.goalColumn
      ),
      forward,
      height
    );
    return internalSelToCM(
      import_state4.EditorSelection.range(selection.anchor, next.head, next.goalColumn),
      doc
    );
  });
}
function moveByLine(view, mode, forward) {
  const select = mode.type === 4;
  const next = select ? selectByLine(view, mode, forward) : cursorByLine(view, mode, forward);
  if (view.state.selection.eq(next)) {
    return false;
  }
  view.dispatch({
    selection: next,
    effects: resetCount(mode),
    scrollIntoView: true
  });
  return true;
}
function moveDown(view, mode) {
  return moveByLine(view, mode, true);
}
function moveUp(view, mode) {
  return moveByLine(view, mode, false);
}
function moveLeft(view, mode) {
  moveByChar(view, mode, false);
}
function moveRight(view, mode) {
  moveByChar(view, mode, true);
}
function setFindMode(view, status, mode, metadata) {
  const effect = modeEffect.of({
    type: mode.type,
    minor: 2,
    count: mode.count,
    expecting: {
      minor: status,
      callback: findText,
      metadata
    }
  });
  view.dispatch({ effects: effect });
}
function findText(view, text, {
  inclusive,
  forward
}) {
  const mode = view.state.field(modeField);
  const select = mode.type === 4;
  const resetEffect = select ? MODE_EFF.SELECT : MODE_EFF.NORMAL;
  const count = mode.type === 1 ? 1 : cmdCount(mode);
  const newSelection = mapSel(view.state.selection, (range) => {
    const selection = cmSelToInternal(range, view.state.doc);
    const doc = view.state.doc;
    const start = selection.head;
    const docString = doc.sliceString(0);
    let rawIndex = start;
    for (let _i = 0; _i < count; _i++) {
      if (!forward && rawIndex === 0) {
        rawIndex = -1;
        break;
      }
      rawIndex = forward ? docString.indexOf(text, rawIndex + 1) : docString.lastIndexOf(text, rawIndex - 1);
      if (rawIndex < 0) {
        break;
      }
    }
    if (rawIndex === -1) {
      return range;
    }
    const index = inclusive ? rawIndex : forward ? rawIndex - 1 : rawIndex + 1;
    const next = select ? import_state4.EditorSelection.range(selection.anchor, index) : import_state4.EditorSelection.range(selection.head, index);
    return internalSelToCM(next, doc);
  });
  view.dispatch({
    effects: resetEffect,
    selection: newSelection
  });
}
function moveToSibling(view, forward) {
  const tree = (0, import_language.syntaxTree)(view.state);
  const selection = view.state.selection.main;
  let stack = tree.resolveStack(selection.from, 1);
  let sibling = null;
  while (true) {
    const node = stack.node;
    if (node && node.from <= selection.from && node.to >= selection.to) {
      sibling = forward ? node == null ? void 0 : node.nextSibling : node == null ? void 0 : node.prevSibling;
      if (sibling) {
        break;
      }
    }
    if (stack.next) {
      stack = stack.next;
    } else {
      break;
    }
  }
  if (!sibling) {
    view.dispatch({
      selection: import_state4.EditorSelection.range(0, view.state.doc.length),
      scrollIntoView: true
    });
    return;
  }
  view.dispatch({
    selection: import_state4.EditorSelection.range(sibling.from, sibling.to),
    scrollIntoView: true
  });
}
var PAIRS = {
  "(": ["(", ")", true],
  ")": ["(", ")", false],
  "{": ["{", "}", true],
  "}": ["{", "}", false],
  "[": ["[", "]", true],
  "]": ["[", "]", false],
  "<": ["<", ">", true],
  ">": ["<", ">", false]
};
var MATCHEABLE = /* @__PURE__ */ new Set([...Object.keys(PAIRS), `"`, "'"]);
function matchBracket(view) {
  return view.state.selection.ranges.map((range) => {
    var _a, _b;
    const internal = cmSelToInternal(range, view.state.doc);
    const collapsed = internalSelToCM(
      import_state4.EditorSelection.range(internal.head, internal.head),
      view.state.doc
    );
    const char = view.state.doc.sliceString(collapsed.from, collapsed.to);
    if (!MATCHEABLE.has(char)) {
      return null;
    }
    const open = (_b = (_a = PAIRS[char]) == null ? void 0 : _a[2]) != null ? _b : false;
    const match = (0, import_language.matchBrackets)(
      view.state,
      collapsed.head + (open ? 0 : 1),
      open ? 1 : -1
    );
    if (match) {
      return match.end;
    }
  });
}
function surround(view, char) {
  var _a, _b;
  const pair = PAIRS[char];
  const open = (_a = pair == null ? void 0 : pair[0]) != null ? _a : char;
  const close = (_b = pair == null ? void 0 : pair[1]) != null ? _b : char;
  const offset = open.length + close.length;
  const tr = view.state.changeByRange((range) => {
    const [anchor, head] = rangeIsForward(range) || range.empty ? [range.anchor, range.head + offset] : [range.anchor + offset, range.head];
    return {
      range: import_state4.EditorSelection.range(anchor, head),
      changes: [
        {
          from: range.from,
          insert: open
        },
        {
          from: range.to,
          insert: close
        }
      ]
    };
  });
  view.dispatch(tr, { effects: MODE_EFF.NORMAL });
}
function extendToDelimiters(view, char, inclusive) {
  var _a, _b;
  const mode = view.state.field(modeField);
  const pair = PAIRS[char];
  const open = (_a = pair == null ? void 0 : pair[0]) != null ? _a : char;
  const close = (_b = pair == null ? void 0 : pair[1]) != null ? _b : char;
  const query = new import_search2.SearchQuery({
    search: `${escape(open)}|${escape(close)}`,
    regexp: true
  });
  const ranges = view.state.selection.ranges.map((range) => {
    const cursor = query.getCursor(view.state, range.head);
    let dir = 1;
    let next = cursor.next();
    if (next.done) {
      return range;
    }
    if (open !== close && view.state.sliceDoc(next.value.from, next.value.to) === open) {
      const cursor2 = query.getCursor(view.state, 0, range.head);
      let nextOpen;
      while (true) {
        const next2 = cursor2.next();
        if (next2.done) {
          break;
        }
        nextOpen = {
          done: false,
          value: next2.value
        };
      }
      if (!nextOpen || (nextOpen == null ? void 0 : nextOpen.done) || view.state.sliceDoc(nextOpen.value.from, nextOpen.value.to) === close) {
        return range;
      }
      dir = -1;
      next = nextOpen;
    }
    const match = (0, import_language.matchBrackets)(
      view.state,
      dir > 0 ? next.value.to : next.value.from,
      -dir
    );
    if (!(match == null ? void 0 : match.end)) {
      return range;
    }
    let [start, end] = dir > 0 ? [match.end, next.value] : [next.value, match.end];
    if (!inclusive) {
      const startTo = nextClusterBreak(view.state.doc, start.to, true);
      start = { from: start.to, to: startTo };
      const endFrom = nextClusterBreak(view.state.doc, end.from, false);
      end = { from: endFrom, to: end.from };
    }
    const [anchor, head] = rangeIsForward(range) || rangeIsAtomic(range, view.state.doc) ? [start.from, end.to] : [end.to, start.from];
    return import_state4.EditorSelection.range(anchor, head);
  });
  view.dispatch({
    selection: import_state4.EditorSelection.create(ranges, view.state.selection.mainIndex),
    effects: mode.type === 0 ? MODE_EFF.NORMAL : MODE_EFF.SELECT
  });
}
function replaceWithChar(_, char, view) {
  const selection = view.state.selection.main;
  const selected = view.state.doc.sliceString(selection.from, selection.to);
  let len = 0;
  let offset = 0;
  while (true) {
    const next = (0, import_state4.findClusterBreak)(selected, offset, true);
    if (next === offset) {
      break;
    }
    offset = next;
    len++;
  }
  view.dispatch({
    changes: {
      from: selection.from,
      to: selection.to,
      insert: char.repeat(len)
    },
    effects: MODE_EFF.NORMAL
  });
}
function changeCase(view, upper) {
  view.dispatch(
    view.state.changeByRange((range) => {
      const selected = view.state.doc.sliceString(range.from, range.to);
      let insert;
      if (upper == null) {
        insert = [...selected].map((char) => {
          let next = char.toUpperCase();
          return next === char ? char.toLowerCase() : next;
        }).join("");
      } else if (upper) {
        insert = selected.toUpperCase();
      } else {
        insert = selected.toLowerCase();
      }
      return {
        range,
        changes: {
          from: range.from,
          to: range.to,
          insert
        }
      };
    })
  );
}
function yanksForSelection(selection, yank2) {
  var _a;
  if (selection.ranges.length === yank2.length) {
    return yank2;
  }
  if (selection.ranges.length < yank2.length) {
    return yank2.slice(0, selection.ranges.length);
  }
  const last = (_a = yank2.at(-1)) != null ? _a : "";
  const copy = [...yank2];
  for (let i = yank2.length; i < selection.ranges.length; i++) {
    copy[i] = last;
  }
  return copy;
}
function yank(view, mode, register) {
  var _a;
  const { selection } = view.state;
  register != null ? register : register = (_a = mode.register) != null ? _a : `"`;
  view.dispatch({
    effects: [
      yankEffect.of([
        register,
        selection.ranges.map(
          (range) => view.state.doc.slice(range.from, range.to)
        )
      ]),
      MODE_EFF.NORMAL
    ]
  });
  const total = selection.ranges.length;
  return `yanked ${total === 1 ? "1 selection" : `${total} selections`} to register ${register}`;
}
function paste(view, yanked, before, count, { reset = true, select = true } = {}) {
  const { selection } = view.state;
  yanked != null ? yanked : yanked = [""];
  const yanks = yanksForSelection(selection, yanked);
  const specs = yanks.map((yank2, i) => ({
    from: before ? selection.ranges[i].from : selection.ranges[i].to,
    insert: yank2.toString().repeat(count)
  }));
  const { ranges } = yanks.reduce(
    (acc, yank2, i) => {
      let length = yank2.length;
      let range = selection.ranges[i];
      const anchor = (before ? range.from : range.to) + acc.offset;
      acc.ranges.push(
        select ? import_state4.EditorSelection.range(anchor, anchor + length) : import_state4.EditorSelection.cursor(anchor + length)
      );
      acc.offset += length;
      return acc;
    },
    {
      ranges: [],
      offset: 0
    }
  );
  const change = view.state.changes(specs);
  view.dispatch(
    { changes: change },
    {
      selection: import_state4.EditorSelection.create(ranges, selection.mainIndex),
      sequential: true
    },
    reset ? { effects: MODE_EFF.NORMAL } : {}
  );
}
function changeNumber(view, increase) {
  const re = /-?\d+/;
  view.dispatch(
    view.state.changeByRange((range) => {
      const str = view.state.doc.sliceString(range.from, range.to);
      if (!re.test(str)) {
        return {
          range
        };
      }
      const parsed = Number(str);
      const insert = String(parsed + (increase ? 1 : -1));
      return {
        range: insert.length === str.length ? range : import_state4.EditorSelection.range(range.from, range.from + insert.length),
        changes: {
          from: range.from,
          to: range.to,
          insert
        }
      };
    })
  );
}
function openLine(view, below) {
  let from;
  let cursor;
  const selection = cmSelToInternal(view.state.selection.main, view.state.doc);
  if (below) {
    const line = view.state.doc.lineAt(selection.to);
    from = line.to;
    cursor = from + view.state.lineBreak.length;
  } else {
    const line = view.state.doc.lineAt(selection.from);
    from = line.from;
    cursor = from;
  }
  view.dispatch({
    changes: {
      from,
      insert: view.state.lineBreak
    },
    selection: import_state4.EditorSelection.cursor(cursor),
    effects: MODE_EFF.INSERT
  });
}
var countCommands = Object.fromEntries(
  Array.from({ length: 10 }, (_, count) => [
    String(count),
    (view, mode) => {
      const next = mode.count != null ? mode.count * 10 + count : count;
      if (next === 0) {
        return;
      }
      view.dispatch({
        effects: modeEffect.of({ ...mode, count: next })
      });
    }
  ])
);
function insertLine(view, below) {
  const mode = view.state.field(modeField);
  const count = mode.type === 1 ? 1 : cmdCount(mode);
  const select = mode.type === 4;
  const selection = view.state.selection.main;
  const line = view.state.doc.lineAt(below ? selection.to : selection.from);
  const changes = {
    from: below ? line.to : line.from,
    insert: view.state.lineBreak.repeat(count)
  };
  const resetEffect = select ? MODE_EFF.SELECT : MODE_EFF.NORMAL;
  view.dispatch({ changes, effects: resetEffect });
}
function rotateSelection(view, forward) {
  const { selection } = view.state;
  if (selection.ranges.length === 1) {
    return true;
  }
  const mainIndex = (selection.mainIndex + (forward ? 1 : -1)) % selection.ranges.length;
  view.dispatch({
    selection: import_state4.EditorSelection.create(
      selection.ranges,
      mainIndex + (mainIndex < 0 ? selection.ranges.length : 0)
    )
  });
}
function cmdCount(mode) {
  var _a;
  return (_a = mode.count) != null ? _a : 1;
}
function resetCount(mode) {
  const { count: _count, ...rest } = mode;
  return modeEffect.of(rest);
}
function rangeIsForward(range) {
  return range.head > range.from;
}
function rangeIsAtomic(range, doc) {
  const len = range.to - range.from;
  if (len <= 1) {
    return true;
  } else if (len === 2) {
    const charCode = doc.sliceString(range.from, range.to).charCodeAt(0);
    return charCode >= 55296 && charCode <= 57343;
  } else {
    return false;
  }
}
function nextClusterBreak(doc, pos, forward) {
  if (pos === (forward ? doc.length : 0)) {
    return pos;
  }
  const line = doc.lineAt(pos);
  if (forward && line.to === pos) {
    return pos + 1;
  } else if (!forward && line.from === pos) {
    return pos - 1;
  }
  return (0, import_state4.findClusterBreak)(line.text, pos - line.from, forward) + line.from;
}
function mapSel(selection, mapper) {
  if (selection.ranges.length === 1) {
    const mapped = mapper(selection.main);
    return import_state4.EditorSelection.single(mapped.anchor, mapped.head);
  }
  return import_state4.EditorSelection.create(
    selection.ranges.map(mapper),
    selection.mainIndex
  );
}
function escape(source) {
  return RegExp.escape(source);
}
function backwardsSearch(state, query, mode, select) {
  const cursor = query.getCursor(state);
  const selection = state.selection.main;
  const count = cmdCount(mode);
  const beforeRing = new Ring(count);
  const iter = peekable(cloned(cursor));
  const beforeIter = peekingUntil(iter, (item) => item.to >= selection.from);
  for (const item of {
    [Symbol.iterator]() {
      return beforeIter;
    }
  }) {
    beforeRing.push(item);
  }
  if (beforeRing.length === count) {
    select(beforeRing.first);
    return;
  }
  const afterRing = new Ring(count - beforeRing.length);
  for (const item of {
    [Symbol.iterator]() {
      return iter;
    }
  }) {
    afterRing.push(item);
  }
  const total = afterRing.length + beforeRing.length;
  if (total === 0) {
    return {
      match: false
    };
  }
  if (total === count) {
    select(afterRing.first);
    return {
      wrapped: true
    };
  }
  const all = [...beforeRing, ...afterRing];
  const rem = count % total;
  select(all[all.length - rem - 1]);
  return {
    wrapped: true
  };
}
var Ring = class {
  constructor(length) {
    __publicField(this, "items");
    __publicField(this, "head");
    __publicField(this, "length");
    __publicField(this, "maxLength");
    this.items = Array.from({ length });
    this.maxLength = length;
    this.head = 0;
    this.length = 0;
  }
  get first() {
    return this.items[this.start];
  }
  push(item) {
    this.items[this.head] = item;
    this.head += 1;
    this.length += 1;
    this.head %= this.maxLength;
    this.length = Math.min(this.maxLength, this.length);
  }
  merge(other) {
    for (let i = 0; i < other.length; i++) {
      const item = other.items[(other.start + i) % other.maxLength];
      this.push(item);
    }
  }
  *[Symbol.iterator]() {
    for (let i = 0; i < this.length; i++) {
      yield this.items[(this.start + i) % this.maxLength];
    }
  }
  get start() {
    if (this.length < this.maxLength) {
      return 0;
    } else {
      return (this.head + 1) % this.maxLength;
    }
  }
};
function peekingUntil(iter, check) {
  return {
    next() {
      const item = iter.peek();
      if (item.done) {
        return item;
      }
      if (check(item.value)) {
        return { value: void 0, done: true };
      }
      return iter.next();
    }
  };
}
function peekable(iter) {
  let next = iter.next();
  const peekIter = {
    next() {
      const item = next;
      if (!item.done) {
        next = iter.next();
      }
      return item;
    },
    peek() {
      return next;
    }
  };
  return peekIter;
}
function cloned(iter) {
  return {
    next() {
      return { ...iter.next() };
    }
  };
}
function startSearch(view, mode) {
  var _a, _b;
  const initialScroll = view.scrollSnapshot();
  const initialSelection = view.state.selection;
  let input = "";
  let query = null;
  function reset() {
    view.dispatch({
      selection: initialSelection
    });
    resetScroll(view, initialScroll);
  }
  return {
    // FIXME: this is not correct. We should join the contents of the register here
    // and keep the multi-selection in case somebody pastes from '/'
    init: (_b = (_a = view.state.field(registersField)["/"]) == null ? void 0 : _a.toString()) != null ? _b : "",
    onInput(input_) {
      if (input !== input_) {
        input = input_;
        query = searchQuery(input);
      } else {
        return;
      }
      if (!(query == null ? void 0 : query.valid) && mode !== 2) {
        return;
      }
      if (mode === 1) {
        return;
      }
      if (mode === 2) {
        if (!query.valid) {
          if (!input) {
            view.dispatch({
              selection: initialSelection
            });
          }
          return;
        }
        const selections = [];
        for (const sel of initialSelection.ranges) {
          const match2 = query.getCursor(view.state, sel.from, sel.to);
          for (const matched of {
            [Symbol.iterator]() {
              return match2;
            }
          }) {
            selections.push(matched);
          }
        }
        const newRanges = selections.map(
          (sel) => import_state.EditorSelection.range(sel.from, sel.to)
        );
        const newSelection = newRanges.length === 0 ? initialSelection : import_state.EditorSelection.create(newRanges, 0);
        view.dispatch({
          selection: newSelection
        });
        return;
      }
      let match = query.getCursor(view.state, initialSelection.main.to).next();
      if (match.done) {
        match = query.getCursor(view.state).next();
      }
      if (match.done) {
        reset();
      } else {
        const selection = import_state.EditorSelection.range(
          match.value.from,
          match.value.to
        );
        view.dispatch({
          selection,
          effects: import_view.EditorView.scrollIntoView(selection, { y: "center" })
        });
      }
    },
    onClose(accept) {
      var _a2;
      if (!accept) {
        reset();
        return;
      }
      if (input != null) {
        view.dispatch({
          effects: yankEffect.of(["/", [input]])
        });
      }
      if (mode === 1) {
        const externalCommands = view.state.facet(externalCommandsFacet);
        const query2 = input || readRegister(view.state, "/");
        if (query2) {
          return (_a2 = externalCommands.global_search) == null ? void 0 : _a2.call(externalCommands, query2.toString());
        }
      }
    }
  };
}
function searchQuery(query) {
  return new import_search.SearchQuery({
    search: query,
    regexp: true,
    caseSensitive: /[A-Z]/.test(query)
  });
}
var searchFacet = import_state.Facet.define({
  combine(inputs) {
    const input = inputs[0];
    return input ? searchQuery(input) : void 0;
  }
});
var helixCommandBindings = {
  insert: {
    Backspace(view) {
      (0, import_commands.deleteCharBackward)(view);
    },
    Delete(view) {
      (0, import_commands.deleteCharForward)(view);
    },
    Enter(view) {
      (0, import_commands.insertNewlineAndIndent)(view);
    },
    // we need these two due to https://github.com/codemirror/dev/issues/634
    // FIXME: stuff like Shift-<arrow> doesn't quite work with `editor.cursor-shape.insert === "block"`.
    ArrowLeft: import_commands.cursorCharLeft,
    ArrowRight: import_commands.cursorCharRight,
    Escape(view, mode) {
      if (mode.expecting) {
        view.dispatch({
          effects: MODE_EFF.INSERT
        });
        return true;
      }
      view.dispatch({
        effects: [
          MODE_EFF.NORMAL,
          historyEffect.of({ type: "commit", state: view.state })
        ],
        selection: mapSel(
          view.state.selection,
          (range) => range.empty ? internalSelToCM(range, view.state.doc) : range
        )
      });
    },
    ["Ctrl-r"](view) {
      view.dispatch({
        effects: modeEffect.of({
          type: 1,
          expecting: {
            minor: "<C-r>",
            callback(view2, char, _metadata) {
              const yanked = readRegister(view2.state, char);
              paste(view2, yanked, false, 1, { select: false, reset: false });
              view2.dispatch({
                effects: MODE_EFF.INSERT
              });
            },
            metadata: void 0
          }
        })
      });
    },
    Tab: import_commands.indentMore,
    "Shift-Tab": import_commands.indentLess
  },
  normal: {
    // this one is special: we let it apply to all other minor modes
    Escape(view, mode_) {
      const mode = mode_;
      if (mode.type === 0 && mode.minor === 2 && mode.expecting == null && mode.register == null && mode.count == null) {
        return true;
      }
      view.dispatch({
        effects: [MODE_EFF.NORMAL]
      });
    },
    ["/"](view) {
      const panel = getCommandPanel(view);
      panel.showSearchInput();
    },
    ["s"](view) {
      const panel = getCommandPanel(view);
      panel.showSearchInput(
        2
        /* Selection */
      );
    },
    ["Alt-s"](view) {
      const selections = [];
      const lines = /* @__PURE__ */ new Set();
      for (const range of view.state.selection.ranges) {
        const start = view.state.doc.lineAt(range.from).number;
        const endLine = view.state.doc.lineAt(range.to);
        const end = endLine.from === range.to ? endLine.number - 1 : endLine.number;
        for (let l = start; l <= end; l++) {
          const line = view.state.doc.line(l);
          if (lines.has(line.number)) {
            continue;
          }
          lines.add(line.number);
          selections.push(import_state.EditorSelection.range(line.from, line.to));
        }
      }
      view.dispatch({
        selection: import_state.EditorSelection.create(selections, 0)
      });
    },
    [","](view) {
      if (view.state.selection.ranges.length === 1) {
        return true;
      }
      view.dispatch({
        selection: view.state.selection.asSingle()
      });
    },
    ["("](view) {
      rotateSelection(view, false);
    },
    [")"](view) {
      rotateSelection(view, true);
    },
    ...countCommands,
    [":"](view, mode) {
      view.dispatch({
        effects: resetMode(mode)
      });
      getCommandPanel(view).showCommandInput();
    },
    ["y"](view, mode) {
      getCommandPanel(view).showMessage(yank(view, mode));
    },
    ["a"]: {
      checkpoint: "temp",
      command(view) {
        view.dispatch({
          effects: MODE_EFF.INSERT,
          selection: mapSel(
            view.state.selection,
            (range) => import_state.EditorSelection.range(range.to, range.to)
          )
        });
      }
    },
    ["A"]: {
      checkpoint: "temp",
      command(view, mode) {
        cursorToLineEnd(view, mode, true);
      }
    },
    ["I"]: {
      checkpoint: "temp",
      command(view) {
        view.dispatch({
          effects: MODE_EFF.INSERT,
          selection: mapSel(view.state.selection, (range) => {
            const start = view.state.doc.lineAt(range.from).from;
            return import_state.EditorSelection.cursor(start);
          })
        });
      }
    },
    ["c"]: {
      checkpoint: "temp",
      command(view) {
        removeText(view, { edit: true });
      }
    },
    ["d"]: {
      checkpoint: true,
      command(view) {
        removeText(view);
      }
    },
    ["Alt-c"]: {
      checkpoint: "temp",
      command(view) {
        removeText(view, { yank: false, edit: true });
      }
    },
    ["Alt-d"]: {
      checkpoint: true,
      command(view) {
        removeText(view, { yank: false });
      }
    },
    ["P"]: {
      checkpoint: true,
      command(view, mode) {
        const yanked = readRegister(view.state, mode.register);
        paste(view, yanked, true, cmdCount(mode));
      }
    },
    ["p"]: {
      checkpoint: true,
      command(view, mode) {
        const yanked = readRegister(view.state, mode.register);
        paste(view, yanked, false, cmdCount(mode));
      }
    },
    ["R"]: {
      checkpoint: true,
      command(view, mode) {
        const contents = readRegister(view.state, mode.register);
        if (!contents) {
          return true;
        }
        const count = cmdCount(mode);
        const yanks = yanksForSelection(view.state.selection, contents);
        const replacements = count === 1 ? yanks : yanks.map((yank2) => yank2.toString().repeat(count));
        const byIndex = new Map(
          view.state.selection.ranges.map((range, i) => [range, i])
        );
        const tr = view.state.changeByRange((range) => {
          const insert = replacements[byIndex.get(range)];
          if (!insert) {
            return { range };
          }
          return {
            range: import_state.EditorSelection.range(
              range.from,
              range.from + insert.length
            ),
            changes: {
              from: range.from,
              to: range.to,
              insert
            }
          };
        });
        view.dispatch({
          ...tr,
          effects: [...tr.effects, MODE_EFF.NORMAL]
        });
      }
    },
    ["r"]: {
      checkpoint: true,
      command(view, mode) {
        view.dispatch({
          effects: modeEffect.of({
            ...mode,
            expecting: {
              minor: "r",
              callback: replaceWithChar,
              metadata: view
            }
          })
        });
      }
    },
    ["w"](view, mode) {
      moveByGroup(view, mode, true);
    },
    ["e"](view, mode) {
      moveByGroup(view, mode, true);
    },
    ["b"](view, mode) {
      moveByGroup(view, mode, false);
    },
    ["v"](view, mode) {
      view.dispatch({
        effects: mode.type === 0 ? MODE_EFF.SELECT : MODE_EFF.NORMAL
      });
    },
    ["g"](view, mode) {
      view.dispatch({
        effects: overwriteMode(mode, {
          minor: 3
          /* Goto */
        })
      });
    },
    ["Space"](view, mode) {
      view.dispatch({
        effects: overwriteMode(mode, {
          minor: 6
          /* Space */
        })
      });
    },
    ["m"](view, mode) {
      view.dispatch({
        effects: overwriteMode(mode, {
          minor: 5
          /* Match */
        })
      });
    },
    ["i"]: {
      checkpoint: "temp",
      command(view) {
        view.dispatch({
          effects: MODE_EFF.INSERT,
          selection: mapSel(
            view.state.selection,
            (range) => import_state.EditorSelection.range(range.from, range.from)
          )
        });
      }
    },
    ["h"](view, mode) {
      return moveLeft(view, mode);
    },
    ["j"]: moveDown,
    ["ArrowDown"]: "j",
    ["ArrowUp"]: "k",
    ["k"]: moveUp,
    ["ArrowRight"]: "l",
    ["ArrowLeft"]: "h",
    ["l"](view, mode) {
      return moveRight(view, mode);
    },
    ["%"](view) {
      return (0, import_commands.selectAll)(view);
    },
    ["o"]: {
      checkpoint: "temp",
      command(view) {
        openLine(view, true);
      }
    },
    ["O"]: {
      checkpoint: "temp",
      command(view) {
        openLine(view, false);
      }
    },
    ["f"](view, mode) {
      setFindMode(view, "f", mode, {
        inclusive: true,
        forward: true
      });
    },
    ["F"](view, mode) {
      setFindMode(view, "F", mode, {
        inclusive: true,
        forward: false
      });
    },
    ["t"](view, mode) {
      setFindMode(view, "t", mode, {
        inclusive: false,
        forward: true
      });
    },
    ["T"](view, mode) {
      setFindMode(view, "T", mode, {
        inclusive: false,
        forward: false
      });
    },
    ["u"](view, mode) {
      const { checkpoints, cursor } = view.state.field(historyField);
      const nextCursor = cursor + cmdCount(mode);
      const state = checkpoints[nextCursor];
      if (!state) {
        return true;
      }
      view.dispatch({
        changes: {
          from: 0,
          to: view.state.doc.length,
          insert: state.doc
        },
        selection: state.selection,
        effects: [
          historyEffect.of({
            type: "move",
            offset: cmdCount(mode),
            head: view.state
          }),
          resetCount(mode)
        ],
        scrollIntoView: true
      });
    },
    ["U"](view, mode) {
      const { checkpoints, cursor, head } = view.state.field(historyField);
      const nextCursor = cursor - cmdCount(mode);
      const state = nextCursor === -1 ? head : checkpoints[nextCursor];
      if (!state) {
        return true;
      }
      view.dispatch({
        changes: {
          from: 0,
          to: view.state.doc.length,
          insert: state.doc
        },
        selection: state.selection,
        effects: [
          historyEffect.of({
            type: "move",
            offset: -cmdCount(mode)
          }),
          resetCount(mode)
        ],
        scrollIntoView: true
      });
    },
    ["x"](view, mode) {
      function extend(range) {
        const startLine = view.state.doc.lineAt(range.from);
        let endLine = view.state.doc.lineAt(range.to);
        if (!range.empty && range.to === endLine.from) {
          endLine = view.state.doc.line(endLine.number - 1);
        }
        const ideal = import_state.EditorSelection.range(
          startLine.from,
          Math.min(
            view.state.doc.length,
            endLine.to + view.state.lineBreak.length
          )
        );
        const perfectLineSelection = ideal.from === range.from && ideal.to === range.to;
        if (perfectLineSelection || mode.count) {
          const nextLineNumber = Math.min(
            endLine.number + cmdCount(mode),
            view.state.doc.lines
          );
          const nextLine = view.state.doc.line(nextLineNumber);
          return import_state.EditorSelection.range(
            startLine.from,
            Math.min(
              view.state.doc.length,
              nextLine.to + view.state.lineBreak.length
            )
          );
        } else {
          return ideal;
        }
      }
      view.dispatch({
        selection: mapSel(view.state.selection, extend),
        effects: resetCount(mode)
      });
      return true;
    },
    ["n"](view, mode) {
      const query = view.state.facet(searchFacet);
      if (!(query == null ? void 0 : query.valid)) {
        if (query) {
          showSearchError(view, query);
        }
        view.dispatch({
          effects: resetCount(mode)
        });
        return true;
      }
      let cursor = query.getCursor(view.state, view.state.selection.main.to);
      let match;
      let found = false;
      let wrapped = false;
      for (let _i = 0; _i < cmdCount(mode); _i++) {
        match = cursor.next();
        found || (found = !match.done);
        if (match.done) {
          cursor = query.getCursor(view.state);
          wrapped = true;
          match = cursor.next();
          found || (found = !match.done);
        }
        if (!found) {
          getCommandPanel(view).showError("No more matches");
          return;
        }
      }
      const newRange = import_state.EditorSelection.range(
        match.value.from,
        match.value.to
      );
      let newSel = newRange;
      if (mode.type === 4) {
        newSel = view.state.selection.addRange(newRange);
      }
      view.dispatch({
        selection: newSel,
        scrollIntoView: true
      });
      if (wrapped) {
        getCommandPanel(view).showMessage("Wrapped around document");
      }
    },
    ["N"](view, mode) {
      const query = view.state.facet(searchFacet);
      if (!(query == null ? void 0 : query.valid)) {
        if (query) {
          showSearchError(view, query);
        }
        view.dispatch({
          effects: resetCount(mode)
        });
        return true;
      }
      const result = backwardsSearch(view.state, query, mode, (match) => {
        const selection = import_state.EditorSelection.range(match.from, match.to);
        view.dispatch({
          selection,
          effects: import_view.EditorView.scrollIntoView(selection, { y: "center" })
        });
      });
      if (result == null ? void 0 : result.wrapped) {
        getCommandPanel(view).showMessage("Wrapped around document");
      } else if ((result == null ? void 0 : result.match) === false) {
        getCommandPanel(view).showError("No more matches");
      }
      view.dispatch({
        effects: resetCount(mode)
      });
    },
    ["Ctrl-a"]: {
      checkpoint: true,
      command(view) {
        changeNumber(view, true);
      }
    },
    ["Ctrl-x"]: {
      checkpoint: true,
      command(view) {
        changeNumber(view, false);
      }
    },
    ["Ctrl-d"](view, mode) {
      moveByHalfPage(view, mode, true);
    },
    ["PageDown"]: "Ctrl-d",
    ["PageUp"]: "Ctrl-u",
    ["Ctrl-u"](view, mode) {
      moveByHalfPage(view, mode, false);
    },
    [";"](view) {
      withHelixSelection(view, () => {
        view.dispatch({
          selection: mapSel(
            view.state.selection,
            (range) => import_state.EditorSelection.cursor(range.head)
          ),
          scrollIntoView: true
        });
        return true;
      });
    },
    ["Alt-;"](view) {
      view.dispatch({
        selection: mapSel(
          view.state.selection,
          (range) => rangeIsAtomic(range, view.state.doc) ? range : import_state.EditorSelection.range(range.head, range.anchor)
        ),
        scrollIntoView: true
      });
    },
    ["Alt-:"](view) {
      view.dispatch({
        selection: mapSel(
          view.state.selection,
          (range) => rangeIsAtomic(range, view.state.doc) ? range : import_state.EditorSelection.range(range.from, range.to)
        )
      });
    },
    ["Alt-ArrowUp"](view) {
      expandSyntaxHistory(
        view.state,
        (start, dispatch) => {
          view.dispatch(start);
          (0, import_commands.selectParentSyntax)({
            state: view.state,
            dispatch
          });
        },
        (spec) => view.dispatch(spec)
      );
    },
    ["Alt-o"]: "Alt-ArrowUp",
    ["Alt-i"]: "Alt-ArrowDown",
    ["Alt-ArrowDown"](view) {
      const result = undoSyntaxHistory(view.state);
      if (result) {
        view.dispatch(result);
      }
    },
    ["Alt-ArrowRight"](view) {
      moveToSibling(view, true);
    },
    ["Alt-n"]: "Alt-ArrowRight",
    ["Alt-ArrowLeft"](view) {
      moveToSibling(view, false);
    },
    ["Alt-p"]: "Alt-ArrowLeft",
    ["Ctrl-c"]: {
      checkpoint: true,
      command(view) {
        (0, import_commands.toggleComment)(view);
        view.original.dispatch({
          effects: MODE_EFF.NORMAL
        });
      }
    },
    [">"]: {
      checkpoint: true,
      command(view) {
        return (0, import_commands.indentMore)(view);
      }
    },
    ["<"]: {
      checkpoint: true,
      command(view) {
        return (0, import_commands.indentLess)(view);
      }
    },
    ["`"]: {
      checkpoint: true,
      command(view) {
        changeCase(view, false);
      }
    },
    ["Alt-`"]: {
      checkpoint: true,
      command(view) {
        changeCase(view, true);
      }
    },
    ["~"]: {
      checkpoint: true,
      command(view) {
        changeCase(view);
      }
    },
    ["*"](view) {
      const yanked = new Set(
        view.state.selection.ranges.map(
          (range) => escapeRegex(view.state.doc.sliceString(range.from, range.to))
        )
      );
      const search = [...yanked].join("|");
      view.dispatch({
        effects: yankEffect.of(["/", [search]])
      });
      getCommandPanel(view).showMessage(`register '/' set to '${search}'`);
    },
    ["_"](view) {
      view.dispatch({
        selection: mapSel(view.state.selection, (range) => {
          const selected = view.state.doc.slice(range.from, range.to).toString();
          const trimmed = selected.trim();
          if (trimmed === selected) {
            return range;
          }
          const startOffset = selected.indexOf(trimmed);
          const endOffset = selected.length - trimmed.length - startOffset;
          const anchor = range.anchor === range.from ? range.anchor + startOffset : range.anchor - endOffset;
          const head = range.head === range.to ? range.head - endOffset : range.head + startOffset;
          return import_state.EditorSelection.range(anchor, head);
        })
      });
    },
    ["Home"]: cursorToLineStart,
    ["End"]: cursorToLineEnd,
    ["J"]: {
      checkpoint: true,
      command(view) {
        const selection = view.state.selection.main;
        const { doc } = view.state;
        const startLine = doc.lineAt(selection.from);
        if (startLine.number >= doc.lines) {
          return;
        }
        let endLine = doc.lineAt(selection.to);
        const sameLine = endLine.number === startLine.number;
        if (sameLine) {
          endLine = doc.line(startLine.number + 1);
        }
        let content = "";
        let removed = 0;
        for (let lineNo = startLine.number; lineNo <= endLine.number; lineNo++) {
          let lineContent = startLine.text;
          if (lineNo > startLine.number) {
            const lineText = doc.line(lineNo).text;
            lineContent = lineText.trimStart();
            let trimmed = lineText.length - lineContent.length;
            if (!sameLine && lineNo === endLine.number && selection.to - endLine.from < trimmed) {
              trimmed = selection.to - endLine.from;
            }
            removed += trimmed;
          }
          content += lineContent;
          content += lineNo === endLine.number ? "" : " ";
        }
        const newTo = sameLine ? selection.to : selection.to - removed - (endLine.number - startLine.number) * (view.state.lineBreak.length - 1);
        view.dispatch({
          changes: {
            from: startLine.from,
            to: endLine.to,
            insert: content
          },
          selection: selection.anchor > selection.head ? import_state.EditorSelection.range(newTo, selection.from) : import_state.EditorSelection.range(selection.from, newTo)
        });
      }
    },
    ["["](view, mode) {
      view.dispatch({
        effects: overwriteMode(mode, {
          minor: 7
          /* LeftBracket */
        })
      });
    },
    ["]"](view, mode) {
      view.dispatch({
        effects: overwriteMode(mode, {
          minor: 8
          /* RightBracket */
        })
      });
    },
    [`"`](view, mode) {
      view.dispatch({
        effects: overwriteMode(mode, {
          expecting: {
            minor: `"`,
            metadata: void 0,
            callback(view2, char, _metadata) {
              view2.dispatch({
                effects: modeEffect.of({ ...mode, register: char })
              });
            }
          }
        })
      });
    },
    Tab() {
    },
    ["Shift-Tab"]() {
    }
  },
  goto: {
    ["g"](view, mode) {
      const isNormal = mode.type === 0;
      withHelixSelection(
        view,
        () => isNormal ? (0, import_commands.cursorDocStart)(view) : (0, import_commands.selectDocStart)(view)
      );
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["e"](view, mode) {
      const isNormal = mode.type === 0;
      const start = view.state.selection.ranges[0].from;
      const lastLine = view.state.doc.line(view.state.doc.lines);
      const line = lastLine.text || view.state.doc.lines === 1 ? lastLine : view.state.doc.line(view.state.doc.lines - 1);
      const end = line.from;
      view.dispatch({
        selection: internalSelToCM(
          isNormal ? import_state.EditorSelection.cursor(end) : import_state.EditorSelection.range(start, end),
          view.state.doc
        ),
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT,
        scrollIntoView: true
      });
    },
    ["h"]: cursorToLineStart,
    ["j"](view, mode) {
      const isNormal = mode.type === 0;
      moveDown(view, mode);
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["k"](view, mode) {
      const isNormal = mode.type === 0;
      moveUp(view, mode);
      view.dispatch({
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["l"]: cursorToLineEnd,
    ["n"](view, mode) {
      var _a;
      const externalCommandDefs = view.state.facet(externalCommandsFacet);
      const result = (_a = externalCommandDefs[":buffer-next"]) == null ? void 0 : _a.call(externalCommandDefs);
      getCommandPanel(view).showMessage(result);
      view.dispatch({
        effects: mode.type === 0 ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["p"](view, mode) {
      var _a;
      const externalCommandDefs = view.state.facet(externalCommandsFacet);
      const result = (_a = externalCommandDefs[":buffer-previous"]) == null ? void 0 : _a.call(externalCommandDefs);
      getCommandPanel(view).showMessage(result);
      view.dispatch({
        effects: mode.type === 0 ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    }
  },
  match: {
    ["s"]: {
      checkpoint: true,
      command(view, mode) {
        view.dispatch({
          effects: modeEffect.of({
            type: mode.type,
            minor: 5,
            expecting: {
              minor: "s",
              callback: surround,
              metadata: view
            }
          })
        });
      }
    },
    ["m"](view, mode) {
      var _a;
      const bracketSelections = (_a = matchBracket(view)) != null ? _a : void 0;
      const isNormal = mode.type === 0;
      const selections = bracketSelections.map((bracketSelection) => {
        if (bracketSelection == null) {
          return void 0;
        }
        let selection = import_state.EditorSelection.range(
          bracketSelection.from,
          bracketSelection.to
        );
        if (!isNormal) {
          const bracketCursor = bracketSelection.from;
          const internal = cmSelToInternal(
            view.state.selection.main,
            view.state.doc
          );
          selection = internalSelToCM(
            import_state.EditorSelection.range(internal.anchor, bracketCursor),
            view.state.doc
          );
        }
        return selection;
      });
      view.dispatch({
        selection: import_state.EditorSelection.create(
          view.state.selection.ranges.map((range, i) => {
            var _a2;
            return (_a2 = selections[i]) != null ? _a2 : range;
          }),
          view.state.selection.mainIndex
        ),
        effects: isNormal ? MODE_EFF.NORMAL : MODE_EFF.SELECT,
        scrollIntoView: true
      });
    },
    ["a"](view, mode) {
      view.dispatch({
        effects: modeEffect.of({
          type: mode.type,
          minor: 5,
          expecting: {
            minor: "a",
            callback: extendToDelimiters,
            metadata: true
          }
        })
      });
    },
    ["i"](view, mode) {
      view.dispatch({
        effects: modeEffect.of({
          type: mode.type,
          minor: 5,
          expecting: {
            minor: "i",
            callback: extendToDelimiters,
            metadata: false
          }
        })
      });
    }
  },
  space: {
    ["y"](view, mode) {
      getCommandPanel(view).showMessage(yank(view, mode, "+"));
    },
    ["p"]: {
      checkpoint: true,
      command(view) {
        view.dispatch({ effects: MODE_EFF.NORMAL });
        readClipboard(view.state).then(
          (yanked) => paste(view, yanked, false, 1, { reset: false })
        );
      }
    },
    ["P"]: {
      checkpoint: true,
      command(view) {
        view.dispatch({ effects: MODE_EFF.NORMAL });
        readClipboard(view.state).then(
          (yanked) => paste(view, yanked, true, 1, { reset: false })
        );
      }
    },
    // FIXME: align with the non-clipboard one
    ["R"]: {
      checkpoint: true,
      command(view) {
        view.dispatch({ effects: MODE_EFF.NORMAL });
        readClipboard(view.state).then((yanked) => {
          const tr = view.state.replaceSelection(yanked[0]);
          view.dispatch(tr);
        });
      }
    },
    ["f"](view, mode) {
      var _a;
      const externalCommandDefs = view.state.facet(externalCommandsFacet);
      const result = (_a = externalCommandDefs.file_picker) == null ? void 0 : _a.call(externalCommandDefs);
      getCommandPanel(view).showMessage(result);
      view.dispatch({
        effects: mode.type === 0 ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["b"](view, mode) {
      var _a;
      const externalCommandsDef = view.state.facet(externalCommandsFacet);
      const result = (_a = externalCommandsDef.buffer_picker) == null ? void 0 : _a.call(externalCommandsDef);
      getCommandPanel(view).showMessage(result);
      view.dispatch({
        effects: mode.type === 0 ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    },
    ["/"](view, mode) {
      const enabled = view.state.facet(externalCommandsFacet).global_search != null;
      if (enabled) {
        getCommandPanel(view).showSearchInput(
          1
          /* Global */
        );
      }
      view.dispatch({
        effects: mode.type === 0 ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      });
    }
  },
  leftBracket: {
    ...countCommands,
    ["Space"]: {
      checkpoint: true,
      command(view) {
        insertLine(view, false);
      }
    }
  },
  rightBracket: {
    ...countCommands,
    ["Space"]: {
      checkpoint: true,
      command(view) {
        insertLine(view, true);
      }
    }
  }
};
function moveByGroup(view, mode, forward) {
  const normal = mode.type === 0;
  const tr = view.state.changeByRange((range) => {
    const rangeForward = rangeIsForward(range);
    const [headCursor, anchorCursor] = rangeIsAtomic(range, view.state.doc) ? [range, range] : [
      import_state.EditorSelection.range(
        nextClusterBreak(view.state.doc, range.head, !rangeForward),
        range.head
      ),
      import_state.EditorSelection.range(
        range.anchor,
        nextClusterBreak(view.state.doc, range.anchor, rangeForward)
      )
    ];
    let nextAnchor = forward ? headCursor.from : headCursor.to;
    let nextHead = view.moveByGroup(
      import_state.EditorSelection.cursor(nextAnchor),
      forward
    ).head;
    const oldEnd = forward ? headCursor.to : headCursor.from;
    if (nextHead === oldEnd) {
      nextAnchor = nextHead;
      nextHead = view.moveByGroup(
        import_state.EditorSelection.cursor(nextAnchor),
        forward
      ).head;
    }
    const nextRange = import_state.EditorSelection.range(nextAnchor, nextHead);
    if (!normal) {
      const nextHeadCursor = rangeIsAtomic(nextRange, view.state.doc) ? nextRange : import_state.EditorSelection.range(
        nextClusterBreak(view.state.doc, nextRange.head, !forward),
        nextRange.head
      );
      [nextAnchor, nextHead] = nextHeadCursor.to < anchorCursor.from ? [anchorCursor.to, nextHeadCursor.from] : [anchorCursor.from, nextHeadCursor.to];
      const range2 = import_state.EditorSelection.range(nextAnchor, nextHead);
      return {
        range: range2
      };
    }
    return {
      range: nextRange
    };
  });
  view.dispatch(tr);
}
function toCodemirrorKeymap(keybindings) {
  const allKeys = [
    ...new Set(
      Object.values(keybindings).flat().flatMap((binding) => Object.keys(binding))
    )
  ];
  function apply(def, view, mode) {
    if (typeof def === "function") {
      return def(view, mode);
    } else {
      const temp = def.checkpoint === "temp";
      return def.command(
        {
          original: view,
          dispatch(...args) {
            view.dispatch(commitToHistory(view, temp), ...args);
          },
          get state() {
            return view.state;
          }
        },
        mode
      );
    }
  }
  function getExplicitCommand(key, bindings) {
    while (true) {
      const binding = bindings[key];
      if (typeof binding === "string") {
        key = binding;
        continue;
      }
      return binding;
    }
  }
  const codemirrorKeybindings = [];
  for (const key of allKeys) {
    const insertCommand = getExplicitCommand(key, keybindings.insert);
    const normalCommand = getExplicitCommand(key, keybindings.normal);
    const gotoCommand = getExplicitCommand(key, keybindings.goto);
    const matchCommand = getExplicitCommand(key, keybindings.match);
    const spaceCommand = getExplicitCommand(key, keybindings.space);
    const leftBracketCommand = getExplicitCommand(
      key,
      keybindings.leftBracket
    );
    const rightBracketCommand = getExplicitCommand(
      key,
      keybindings.rightBracket
    );
    const esc = key === "Escape";
    const isChar = key.length === 1 || key === "Space";
    const command = (view) => {
      var _a;
      const mode = view.state.field(modeField);
      if (mode.type === 1) {
        if (insertCommand) {
          return (_a = insertCommand(view, mode)) != null ? _a : true;
        } else {
          return false;
        }
      }
      if (mode.expecting && isChar) {
        return false;
      }
      let result;
      if (esc || mode.minor === 2 && normalCommand) {
        result = apply(normalCommand, view, mode);
      } else if (mode.minor === 3 && gotoCommand) {
        result = apply(gotoCommand, view, mode);
      } else if (mode.minor === 5 && matchCommand) {
        result = apply(matchCommand, view, mode);
      } else if (mode.minor === 6 && spaceCommand) {
        result = apply(spaceCommand, view, mode);
      } else if (mode.minor === 7 && leftBracketCommand) {
        result = apply(leftBracketCommand, view, mode);
      } else if (mode.minor === 8 && rightBracketCommand) {
        result = apply(rightBracketCommand, view, mode);
      } else {
        return false;
      }
      return result != null ? result : true;
    };
    codemirrorKeybindings.push({
      key,
      run: command
    });
  }
  return codemirrorKeybindings;
}
var EndLineCursor = class extends import_view.WidgetType {
  toDOM() {
    const span = document.createElement("span");
    span.classList.add("cm-hx-cursor");
    span.classList.add("cm-hx-cursor-endline");
    span.textContent = " ";
    return span;
  }
};
var cursorMark = import_view.Decoration.mark({ class: "cm-hx-cursor" });
var endlineCursorWidget = import_view.Decoration.widget({
  widget: new EndLineCursor(),
  side: 1
});
function drawCursorMark(selection, doc) {
  const headSelections = selection.ranges.map(
    (range) => internalSelToCM(
      import_state.EditorSelection.cursor(cmSelToInternal(range, doc).head),
      doc
    )
  );
  const decorations = [];
  for (const headSel of headSelections) {
    const line = doc.lineAt(headSel.head);
    if (headSel.from === doc.length || line.to === headSel.from) {
      decorations.push(endlineCursorWidget.range(headSel.from, headSel.from));
    } else {
      decorations.push(cursorMark.range(headSel.head, headSel.anchor));
    }
  }
  return import_view.Decoration.set(decorations);
}
function letThrough(tr) {
  return tr;
}
var selectByClickFilter = import_state.EditorState.transactionFilter.from(
  modeField,
  (mode) => mode.type === 1 ? letThrough : (tr) => {
    const userEvent = tr.annotation(import_state.Transaction.userEvent);
    if (userEvent !== "select.pointer") {
      return tr;
    }
    const selection = tr.newSelection.main;
    if (!selection.empty) {
      return tr;
    }
    return [
      tr,
      {
        selection: internalSelToCM(selection, tr.newDoc)
      }
    ];
  }
);
var unhandledCommandsFilter = import_state.EditorState.transactionFilter.from(
  modeField,
  (mode) => mode.type === 1 ? letThrough : (tr) => {
    const userEvent = tr.annotation(import_state.Transaction.userEvent);
    if (userEvent == null) {
      return tr;
    }
    if (userEvent === "input.drop" || userEvent === "move.drop") {
      return [];
    }
    if (!userEvent.startsWith("input")) {
      return tr;
    }
    if (!userEvent.startsWith("input.type")) {
      return tr;
    }
    if (mode.minor !== 2) {
      return {
        effects: mode.type === 0 ? MODE_EFF.NORMAL : MODE_EFF.SELECT
      };
    }
    return [];
  }
);
var expectingInputHandler = import_view.EditorView.inputHandler.from(
  modeField,
  (mode) => (view, _from, _to, text) => {
    if (mode.expecting) {
      mode.expecting.callback(view, text, mode.expecting.metadata);
      return true;
    }
    return false;
  }
);
var modeUpdateListener = import_view.EditorView.updateListener.of((viewUpdate) => {
  const { state, startState } = viewUpdate;
  const panel = (0, import_view.getPanel)(viewUpdate.view, statusPanel);
  const mode = state.field(modeField);
  const startMode = startState.field(modeField, false);
  if (mode !== startMode) {
    const startExternalMode = startMode ? toExternalMode(startMode) : void 0;
    const externalMode = toExternalMode(mode);
    if (startExternalMode !== externalMode || mode.register !== (startMode == null ? void 0 : startMode.register)) {
      panel.setMode(externalMode, mode.register);
    }
  }
  panel.setLineCol();
});
var helixKeymap = import_view.keymap.of(toCodemirrorKeymap(helixCommandBindings));
var externalCommandsFacet = import_state.Facet.define({
  combine(values) {
    const handlers = [...values];
    handlers.reverse();
    if (false) {
      const merged = values.reduce((acc, defs) => {
        for (const key of Object.keys(defs)) {
          if (acc[key] == null) {
            acc[key] = 1;
          } else {
            acc[key]++;
          }
        }
        return acc;
      }, {});
      const multiple = Object.entries(merged).flatMap(
        ([key, count]) => count > 1 ? [key] : []
      );
      if (multiple.length > 0) {
        console.warn(
          `Multiple definitions found for external commands: ${multiple.join(
            ", "
          )}`
        );
      }
    }
    return handlers.reduce((acc, def) => {
      return { ...acc, ...def };
    }, {});
  }
});
var pathRegister = import_state.Facet.define({
  combine(values) {
    return values.at(-1);
  }
});
var commands = import_state.Facet.define({
  combine(commands2) {
    const combined = commands2.flat();
    return combined.sort(
      (cmdA, cmdB) => cmdA.name < cmdB.name ? -1 : cmdA.name > cmdB.name ? 1 : 0
    );
  }
});
var exportedResetMode = MODE_EFF.NORMAL;
var themeFacet = import_state.Facet.define({ static: true });
function changeTheme(view, theme, notify = true) {
  const { themes } = view.state.field(themeField);
  const themeObj = themes.find((themeObj2) => themeObj2.name === theme);
  if (!themeObj) {
    return {
      message: `'theme': Could not load theme: ${theme}`,
      error: true
    };
  }
  const currentThemeExtensions = themeCompartment.get(view.state);
  if (Array.isArray(currentThemeExtensions) && currentThemeExtensions.includes(themeObj.extension)) {
    return;
  }
  const promise = typeof themeObj.extension === "function" ? themeObj.extension() : Promise.resolve(themeObj.extension);
  promise.then((extension) => {
    view.dispatch({
      effects: [
        themeCompartment.reconfigure([
          extension,
          themeObj.dark ? panelTheme.dark : panelTheme.light
        ]),
        themeEffect.of(theme)
      ]
    });
    if (notify) {
      view.state.facet(themeFacet).forEach((cb) => cb(themeObj));
    }
  });
}
function helix(options = {}) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const cursorShape = (_b = (_a = options == null ? void 0 : options.config) == null ? void 0 : _a["editor.cursor-shape.insert"]) != null ? _b : "block";
  const globalState = (_c = options.globalInit) != null ? _c : options.init;
  const initialRegisters = globalState instanceof import_state.EditorState ? globalState.field(registersField) : globalState ? globalState.registers : void 0;
  const initialHistory = options.init instanceof import_state.EditorState ? options.init.field(historyField) : options.init ? options.init.history : void 0;
  const initialRegistersHistory = globalState instanceof import_state.EditorState ? globalState.field(registersHistoryField) : globalState ? globalState.registersHistory : void 0;
  const initialThemeName = globalState instanceof import_state.EditorState ? (_d = globalState.field(themeField, false)) == null ? void 0 : _d.current : globalState ? globalState.theme : (_e = options.config) == null ? void 0 : _e.theme;
  if (initialThemeName != null && !((_f = options.themes) == null ? void 0 : _f.length)) {
    throw new Error(
      "options.config.theme only takes effect if options.themes was provided."
    );
  }
  const initialTheme = initialThemeName ? (_g = options.themes) == null ? void 0 : _g.find((theme) => theme.name === initialThemeName) : (_h = options.themes) == null ? void 0 : _h[0];
  if (initialThemeName && !initialTheme) {
    throw new Error(`Unknown theme ${initialThemeName}`);
  }
  const initialThemeExtension = typeof (initialTheme == null ? void 0 : initialTheme.extension) === "function" ? void 0 : initialTheme == null ? void 0 : initialTheme.extension;
  const themeExtensions = initialTheme ? [
    themeField.init(() => ({
      current: initialTheme.name,
      themes: options.themes
    }))
  ] : [panelTheme.light];
  if (initialThemeExtension) {
    themeExtensions.push(
      themeCompartment.of([
        initialThemeExtension,
        initialTheme.dark ? panelTheme.dark : panelTheme.light
      ])
    );
  } else if (initialTheme) {
    themeExtensions.push([
      themeCompartment.of([panelTheme.light]),
      import_view.ViewPlugin.define((view) => {
        changeTheme(view, initialTheme.name, false);
        return {};
      })
    ]);
  }
  return [
    ...themeExtensions,
    import_view.EditorView.theme({
      ".cm-hx-block-cursor .cm-cursor": {
        display: "none !important"
      },
      ".cm-hx-block-cursor .cm-hx-cursor": {
        background: "#ccc"
      }
    }),
    panelStyles,
    (0, import_view.drawSelection)({
      cursorBlinkRate: 0,
      drawRangeCursor: cursorShape === "bar"
    }),
    helixKeymap,
    modeField,
    initialHistory ? historyField.init(() => initialHistory) : historyField,
    initialRegisters ? registersField.init(() => initialRegisters) : registersField,
    initialRegistersHistory ? registersHistoryField.init(() => initialRegistersHistory) : registersHistoryField,
    searchFacet.from(registersField, (registers) => {
      var _a2;
      return (_a2 = registers["/"]) == null ? void 0 : _a2.toString();
    }),
    unhandledCommandsFilter,
    selectByClickFilter,
    expectingInputHandler,
    import_state.EditorState.allowMultipleSelections.of(true),
    import_state.EditorState.transactionFilter.from(
      syntaxHistoryField,
      ({ selections }) => selections.length === 0 ? letThrough : (tr) => {
        for (const effect of tr.effects) {
          if (effect.is(syntaxHistoryEffect)) {
            return tr;
          }
        }
        return [tr, { effects: syntaxHistoryEffect.of({ type: "reset" }) }];
      }
    ),
    import_view.EditorView.decorations.compute(["selection", "doc", modeField], (state) => {
      if (cursorShape === "bar" && state.field(modeField).type === 1) {
        return import_view.Decoration.set([]);
      }
      return drawCursorMark(state.selection, state.doc);
    }),
    modeUpdateListener,
    import_view.showPanel.of(statusPanel),
    import_view.showPanel.of(commandPanel),
    syntaxHistoryField,
    import_view.ViewPlugin.define((view) => {
      view.scrollDOM.classList.add("cm-hx-block-cursor");
      if (view.state.doc.length !== 0) {
        setTimeout(() => {
          view.dispatch({
            selection: import_state.EditorSelection.range(1, 0)
          });
        });
      }
      return {
        update(update) {
          const mode = update.state.field(modeField);
          const startMode = update.startState.field(modeField);
          const panel = getCommandPanel(view);
          if (panel.hasMessage() && update.docChanged || update.selectionSet) {
            panel.clearMessage();
          }
          const modeChanged = !sameMode(mode, startMode);
          if (modeChanged || !sameModeState(mode, startMode)) {
            panel.showMinor(mode);
          }
          if (modeChanged && cursorShape === "bar") {
            view.scrollDOM.classList.toggle(
              "cm-hx-block-cursor",
              mode.type !== 1
              /* Insert */
            );
          }
        }
      };
    }),
    commands.of([
      {
        name: "goto",
        aliases: ["g"],
        help: "Goto line number",
        handler(view, args) {
          if (args.length === 0) {
            return { message: "Line number required", error: true };
          }
          const lineNo = Number(args[0]);
          if (!Number.isFinite(lineNo) || lineNo <= 0) {
            return { message: "Invalid line number", error: true };
          }
          const effectiveLine = Math.min(lineNo, view.state.doc.lines);
          const line = view.state.doc.line(effectiveLine);
          view.dispatch({
            selection: import_state.EditorSelection.cursor(line.from),
            scrollIntoView: true
          });
        }
      },
      {
        name: "clipboard-yank",
        help: "Yank main selection into system clipboard",
        handler(view) {
          const selection = view.state.selection.main;
          navigator.clipboard.writeText(
            view.state.doc.slice(selection.from, selection.to).toString()
          );
          return { message: "Yanked main selection to + register" };
        }
      },
      {
        name: "clear-register",
        help: "Clear given register. If no argument is provided, clear all registers",
        // FIXME: autocomplete
        handler(view, args) {
          if (args.length > 1) {
            return {
              message: `Expected at most 1 argument, got ${args.length}`,
              error: true
            };
          }
          if (args.length === 0) {
            const registers = view.state.field(registersField);
            view.dispatch({
              effects: Object.keys(registers).map(
                (reg) => yankEffect.of([reg, []])
              )
            });
          } else {
            if (args[0].length > 1) {
              return { message: `invalid register ${args[0]}`, error: true };
            }
            view.dispatch({
              effects: yankEffect.of([args[0], []])
            });
          }
        }
      },
      {
        name: "echo",
        help: "Prints the given argumens to the statusline.",
        handler(_view, args) {
          return { message: args.join(" ") };
        }
      },
      ...options.themes != null && options.themes.length > 0 ? [
        {
          name: "theme",
          help: "Change the editor theme (or show the current them if none specified)",
          autocomplete([themeName, extra]) {
            var _a2, _b2;
            if (extra) {
              return [];
            }
            return (_b2 = (_a2 = options.themes) == null ? void 0 : _a2.flatMap(
              (theme) => theme.name.startsWith(themeName) ? [theme.name] : []
            )) != null ? _b2 : [];
          },
          handler(view, args) {
            if (args.length > 1) {
              return {
                message: `Expected at most 1 argument, got ${args.length}`,
                error: true
              };
            }
            if (args.length === 0) {
              return { message: view.state.field(themeField).current };
            }
            return changeTheme(view, args[0]);
          }
        }
      ] : []
    ]),
    commands.compute([externalCommandsFacet], (state) => {
      const externalCommands = state.facet(externalCommandsFacet);
      const hardcodedCommands = [
        [":buffer-next", "Goto next buffer", ["bn", "bnext"]],
        [":buffer-previous", "Goto previous buffer", ["bp", "bprev"]]
      ];
      const bufferClose = externalCommands[":buffer-close"] ? {
        name: "buffer-close",
        aliases: ["bc", "bclose"],
        help: "Close the current buffer",
        autocomplete: externalCommands[":buffer-close"].autocomplete,
        handler(view, args) {
          var _a2;
          const defs = view.state.facet(externalCommandsFacet);
          return (_a2 = defs[":buffer-close"]) == null ? void 0 : _a2.handler(args);
        }
      } : void 0;
      return [
        ...hardcodedCommands.filter(([name]) => !!externalCommands[name]).map(([name, help, aliases]) => ({
          name: name.slice(1),
          aliases,
          help,
          handler(view) {
            var _a2;
            const defs = view.state.facet(externalCommandsFacet);
            return (_a2 = defs[name]) == null ? void 0 : _a2.call(defs);
          }
        })),
        ...bufferClose ? [bufferClose] : []
      ];
    })
  ];
}
function commandPanel(view) {
  return new CommandPanel(view, commands, (mode) => startSearch(view, mode));
}
function getCommandPanel(view) {
  return (0, import_view.getPanel)(view, commandPanel);
}
function toExternalMode(mode) {
  switch (mode.type) {
    case 0:
      return "NOR";
    case 4:
      return "SEL";
    case 1:
      return "INS";
  }
}
function commitToHistory(view, temp = false) {
  return {
    effects: historyEffect.of({
      type: "add",
      state: view.state,
      temp
    })
  };
}
function showSearchError(view, query) {
  let message = "";
  try {
    query.getCursor(view.state);
  } catch (error) {
    message = error == null ? void 0 : error.message;
  }
  getCommandPanel(view).showError(
    `Invalid regex /${query.search}/: ${message}`
  );
}
function resetScroll(view, effect) {
  requestAnimationFrame(
    () => requestAnimationFrame(() => {
      view.dispatch({ effects: effect });
    })
  );
}
function escapeRegex(text) {
  return text.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// main.ts
var import_state5 = require("@codemirror/state");
var import_obsidian = require("obsidian");

// src/logic.ts
var import_view3 = require("@codemirror/view");
var DEFAULT_SETTINGS = {
  enableHelixKeybindings: false,
  // Following the defualt Obsidian behavior, instead of the Helix one.
  cursorInInsertMode: "bar"
};
var DEFAULT_EDITOR_VIEW = import_view3.EditorView.theme({
  ".cm-hx-block-cursor .cm-hx-cursor": {
    background: "var(--text-accent)"
  }
});

// main.ts
var HelixPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.extensions = [];
    this.addSettingTab(new HelixSettingsTab(this.app, this));
    this.setEnabled(this.settings.enableHelixKeybindings, false);
    this.registerEditorExtension(this.extensions);
    this.addCommand({
      id: "toggle-helix-keybindings",
      name: "Toggle Helix keybindings",
      callback: async () => this.setEnabled(!this.settings.enableHelixKeybindings, true, true)
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async setEnabled(value, reload = true, print = false) {
    this.settings.enableHelixKeybindings = value;
    this.extensions.length = 0;
    if (value) {
      this.extensions.push(import_state5.Prec.high(DEFAULT_EDITOR_VIEW));
      this.extensions.push(import_state5.Prec.high(helix({
        config: {
          "editor.cursor-shape.insert": this.settings.cursorInInsertMode
        }
      })));
    }
    await this.saveSettings();
    if (reload)
      this.app.workspace.updateOptions();
    if (print) {
      const msg = value ? "Enabled" : "Disabled";
      new import_obsidian.Notice(`${msg} Helix keybindings`);
    }
  }
  async reload() {
    await this.setEnabled(this.settings.enableHelixKeybindings);
  }
};
var HelixSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("p", { text: "Vim keybindings must be disabled for the plugin to work" });
    new import_obsidian.Setting(containerEl).setName("Enable Helix keybindings").addToggle(async (value) => {
      value.setValue(this.plugin.settings.enableHelixKeybindings).onChange(async (value2) => this.plugin.setEnabled(value2));
    });
    new import_obsidian.Setting(containerEl).setName("Cursor in insert mode").addDropdown((dropDown) => {
      dropDown.addOption("block", "Block");
      dropDown.addOption("bar", "Bar");
      dropDown.setValue(this.plugin.settings.cursorInInsertMode);
      dropDown.onChange(async (value) => {
        if (value == "block" || value == "bar") {
          this.plugin.settings.cursorInInsertMode = value;
          await this.plugin.saveSettings();
          await this.plugin.reload();
        }
      });
    });
  }
};
